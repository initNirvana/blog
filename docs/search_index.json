[
["_main.html", "안녕하세요! (PART) 2017 may 1 소프트웨어 번역어 선택의 어려움 (PART) 2017 june 2 load를 불러오시겠습니까? (PART) 2017 July 3 97년 전산 순화 용어 훑어보기 그리고 한자 4 Random Number in a nutshell (PART) 2017 October 5 Simplex Method와 양키스", " 안녕하세요! 해탈의 블로그입니다. 이전에 했던 위키는 긴글을 쓰는데에 어려움이 있었고, 텀블러의 경우는 블로그의 형태를 띄고 있지만, 부끄러운 글들이 많거나 수정해야할 부분, 테마 수정등이 조금 어려웠습니다. 기존의 위키에 있던 글들을 수정 및 보완하거나 생각해둔 글감들을 써보면서 긴 글을 쓰는 블로그를 운영해볼것 같네요. :) 새로운 블로그로 옮겼습니다. gitbook이 맘에 들어서 이 블로그도 유지합니다. (PART) 2017 may 1 소프트웨어 번역어 선택의 어려움 2017 may 프로그래밍 용어, 무리해서 번역하지 말고 사용합시다를 예전에 읽었었는데, 참 공감이 가는 글이다. 그러나 글을 쓸 때의 대전제는 읽기 쉬운 글을 쓴다는 것이다. 알기 쉽도록 하기 위해선 어느정도 용어를 번역해야 한다. 위키백과에서 충격받은 번역어 번역할 때 한국어 위키백과 참고를 많이 참고하는 편은 아니지만, 적어도 한번은 번역 용어를 어떻게 사용하고 있는지 알아보기 위해 참고한다. 이전에 책에서 본 번역가들이 참고했다고 했던 위키백과 참고해보려고 했으나 내용이 빈약하다. 그리고 정말 실력있는 에디터가 위키백과 수정을 하고 있는지 의문이다. 위키백과가 정말 누구나 편집할 수 있다는 점이 장점이지만 고민을 많이한 문서들은 별로 없는 것 같아 보인다. 나무위키는 논외로 한다. 예를 들어 누가 푸시다운 오토마타를 내리누름 오토마타로 번역한단 말인가? 위키백과 하단의 표를 보도록 하자. 내리누름 오토마타는 직관적이지 않다! 또 다른 예로 번역어의 모호성에서는 람다 대수(lambda calculus)가 정확히 대수(algebra)를 의미하지는 않는다. lambda calculus는 람다 계산법이 적절하다. 단어가 뜻하는 의미를 포괄하기 컴퓨터과학 번역어는 어렵다. 일반적으로 단어에서 단어가 뜻하는 의미를 전부 포괄할 수는 없다. 컴퓨터 과학 용어 번역의 목적은 독자의 이해를 최대한 돕도록 하는 것이다. 초보자 대상으로 한 용어는 대부분 번역이 되어있는 경우가 많다. 번역을 하면서 번역용어를 정리 하고있다. 대부분 대한수학회 용어를 먼저 참고하고있다. 다음은 번역하면서 고민을 해본 용어 목록이다. 이 목록은 계속 수정할 것이다. 심볼(symbol) : 심볼은 의미 그대로 한다면 기호다. 튜링기계에서는 알파벳 26개를 기반한 문자 집합을 말한다. 기호로 번역한다면 그 의미는 어떻게 되는가? 튜링기계의 헤드도 마찬가지다. 누가 헤드를 머리로 번역할까1. accepting state : 오토마타에서 받아들이는 상태, 수용상태 둘 중에 하나를 쓰고 있는 상황이다. 옛날 책을 보면 수용 상태. 위키백과는 받아들이는 상태가 보인다. linear bound automata : 컴퓨터 과학 용어의 의미를 포괄하는 단어를 만드는건 정말 어렵다. linear bound automata는 pushdown automaton과 같이 비결정적으로 동작할 수 있지만, 단일 메인 테이프를 사용하며 보조 테이프를 가지고 있지는 않다. 그리고 linear bound automata은 테이프에 읽기/쓰기가 가능하다. 하지만 linear bound automata은 다른 오토마타처럼 다른 방향으로 이동할 수 없다. 이런 내용은 기존 영어 단어도 의미를 포괄하지 못한다. Convex-hull : 컨벡스 헐, 알고리즘 문제 풀이를 할때 자주 볼 수 있을 것이다. 볼록껍질 의미는 맞다. 정말 볼록껍질로 해야할까? word problem : 구글에 검색해보면 수학에서 말하는 문장 문제(혹은 문장제)가 나온다. 그러나 컴퓨터 과학에서 말하는 word problem은 다르다. 단어 문제라고 해야할 것이다. withness : 위키백과에서는 증거, 친절한 수론 길라잡이에서는 증인으로 사용한다. n이 홀수인 합성수일때 \\({1, 2, 3, … , n-1}\\) 의 75%의 수가 withness를 가지고 있다. 라는 미하엘 라빈의 정의를 본다면 증거 혹은 증인이 맞아 보인다. minima : 수학용어에서는 극소다. 다만 스타이너 트리를 찾는 아날로그 방법인 비눗방울 방법2으로 하는데 극소를 쓴다? 그건 아닐것이다. list comprehensions : 리스트 해석, 리스트 조건제시법, 어느정도 해당하는 말일 수 있다. 하지만 다양하게 사용되는 컴프리헨션에 대응이 될 수 없다. 음차로 쓰는것을 추천한다. 사실 이렇게 엉망인 이유는 하나 더 있는데, 컴퓨터과학에는 수학의 개념을 차용한 개념들이 많이 있다. 처음에 링크한 글에는 parameter와 매개변수를 비교했는데, 문제가 조금 복잡하다. 사실 매개변수는 수학 용어에서 왔기때문이다34. 그리고 invariant와 immutable 는 둘다 수학에서 불변이라는 의미다. argument는 수학에서 편각, 변수로 쓰고 있다. 반면 컴퓨터 과학용어로 번역을 했을때는 인수로 쓰고 있다. parameter와 argument의 차이를 설명한 인용을 보도록 하자. We well generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function. - K&amp;R, C Programming Language (2nd Edition), p.25 결론 과거로 돌아가서 번역할때 한자 쓰지말자고 하기에는 타임머신이 개발되지 않았다. 과거의 한자용어의 익숙함도 문제지만 한글로 번역하면 의미가 한 글자로 압축되어 있는 한자보다 긴 단어가 될 가능성이 있다. 한글의 표현 한계에도 금방 부딪힐 것이다. 이정도로 한국어 문서가 빈약할 줄은 몰랐어 요약하면 쉽게 읽히기 위한 글(번역)을 쓰기 위해선 어느정도 용어를 번역해야 한다. 초보자를 대상으로 하는 책은 더더욱 용어를 번역해야한다. 위키백과는 참고는 할만하지만 번역용어 제시 사이트로는 좋지 못한 상태다. 한국어 웹 문서는 빈약하다. (PART) 2017 june 2 load를 불러오시겠습니까? 2017 june 예전에 TAOCP 1권의 MMIX 부분을 읽고 있던 중 적재(load)라는 단어를 보게 되었다. LDA는 알고 있었으나 Load라는 단어의 뜻은 불러오기밖에 몰랐었다. 일단 TAOCP 1권에서 LDA를 설명하는 인용5을 보도록 하자. LDA (load A; A에 적재). C = 8; F = 필드 CONTENTS(M)의 지정된 필드로 레지스터 A의 이전 내용을 대체 한다. 부분 필드가 입력으로 쓰이는 모든 명령에서, 필드 자체에 부호가 포함되어 있으면 그 부호가 쓰이고, 그렇지 않으면 부호는 +로 간주된다. 레지스터에 적재될 때, 필드는 그 오른쪽 끝이 레지스터의 오른쪽 끝에 일치하도록 적절히 이동된다. 이해하기 어렵다. 책의 예제를 보자. 예 : F가 정규 필드 명세 (0:5)이면 장소 M의 모든 내용이 rA에 복사된다. F가 (1:5)이면 CONTENTS(M)의 절대값이 부호 +와 함께 적재된다. M에 어떤 명령 워드가 들어 있으며 F가 (0:2)이면 그 “±AA 필드”가 A에 다음과 같이 적재된다. [±000AA] 이번엔 다른 책6을 보자. LOAD : 기억장치로부터 데이터를 읽어서 누산기(AC)에 적재 또 다른 책7을 보자. 명령어 LDA | LDA B | 피연산자의 자료 B(주소 B의 자료)를 레지스터에 가져오는 명령어 뭔가 조금 다르다. 같은 LDA가 맞는지 혼란스럽다. 다른 책 알아보는건 그만두고, 영문을 보자. LDA X : Load the AC with the contents of memory address X. AC에 메모리 주소 X의 내용을 적재한다. AC에 메모리 주소 X의 내용을 불러온다. 누가 적절하지 않은 용어를 쓰고 있을까? 용어 이야기는 여기까지 하고 컴퓨터 내부로 가보자. 니모닉 LDA를 실행하면 내부에서 어떤일이 일어날까? 다음은 LOAD addr의 마이크로 연산이다. \\(t_0 : MAR \\leftarrow IR(addr) \\\\\\) \\(t_1 : MBR \\leftarrow M[MAR] \\\\\\) \\(t_2 : AC \\leftarrow MBR \\\\\\) 첫번째 주기에서는 명령어 레지스터 IR에 loaded한 명령어의 오퍼랜드인 주소(addr)를 MAR을 통하여 기억장치로 보낸다. 두번째 주기에는 주소가 지정하는 기억장소로부터 데이터를 인출하여 MBR에 저장하며, 그 데이터를 세번째 주기에서 AC 레지스터에 load함으로써 LOAD 명령어의 실행이 완료된다. load(or loaded)를 적재나 불러오기로 읽어보라. 이번엔 다른 예문을 보자. 메모리 주소 X의 내용을 언급할때는, 주소가 X인 메모리 워드에 현재 저장된 정수를 말한다. AC에 메모리 주소 X의 내용을 간접적으로 적재한다는 의미는, 주소 X의 내용을 적재하는 것이 아닌(내용(contents)가 적재됬을때) 다른 주소의 내용으로 처리한다는 것을 의미한다. 적재를 불러온다로 바꿔보자. AC에 메모리 주소 X의 내용을 간접적으로 불러온다는 의미는, 주소 X의 내용을 불러오는것이 아닌(내용(contents)을 불러왔을때) 다른 주소의 내용으로 처리한다는 것을 의미한다. 불러왔다는 의미보다는 적재라는 의미가 더 적절하다. 결론은 단어 공부는 꾸준하게, 안다고 생각하는 것도 다시 보자. (PART) 2017 July 3 97년 전산 순화 용어 훑어보기 그리고 한자 2017 July 글을 쓰거나 통신을 하는데 필수적인 것은 서로 의미를 정확하게 이해할 올바른 용어 사용이다. 같은 단어를 사용하더라도 의미가 불분명하거나 이해하기 어렵게 사용한다면 의미를 제대로 전달할 수 없을것이다. 이번 글에서는 97년도 전산 순화 용어 를 살펴보자. 오래된 전공책으로 공부한 사람들은 눈에 익은 단어들도 있을 것이다. 97년도에서 제안하여 지금까지 남아있는 단어도 있을 수도 있다. 그리고 단어에 따라 복합적인 결과일 수도 있다. 다음의 용어들은 통일할 수 있기를 바라는 점에서 제안을 했다는 것을 유의해야한다. 아래는 눈에 띄는 단어만 추려본 것이다. [A] absolute address 「 순」 절대 번지 : 절대 번지는 번지가 주소로 바뀌어 현재까지 이어졌다. 물론 절대 주소가 계속 이어져온것일 수도 있다. accumulator 「 순」 누산기(累算器) : 누산기가 번역 용어로서, 전달력에 있어서 적절한가? 라는 의문을 가진다면 미흡할 수도 있다. 그러나 이 한자용어를 대체할 수 있는 단어가 마땅히 생각이 나지 않는다. adder 「 순」 덧셈기 : 가산기와 혼용해서 사용하고 있다. AND(앤드) 「 ↔」 또 AND gate 「 순」 또문, 앤드문 AND operation 「 순」 또셈, 앤드셈 또셈(기타 -셈 등등)은 영어 앤드샘에 밀려 사용되지 못했다. argument 「 순」 인수(引數) : 이전 글에서 언급하였다. 컴퓨터 과학 용어로서 인수는 적절하다. automata 「 순」 자동 장치 : 오토마타를 자동장치로 한다면 오토마톤은 무엇으로 해야할까? [B] binary search 「 순」 이진찾기 binary tree 「 순」 이진나무꼴 branch 「 순」 가름 bubble sort 「 순」 거품 정렬 [C] cache 「 순」 시렁 cache memory 「 순」 시렁 기억 (장치), 시렁 : 물건을 얹어 놓기 위해, 방이나 마루의 벽에 두 개의 나무를 가로질러 선반처럼 만들어 놓은 것 call by reference 「 순」 참조로 불러내기 call by value 「 순」 값으로 불러내기 : 현재 순우리말 보단 값의 의한~, 참조에 의한~ 으로 사용하고 있다. capture 「 순」 갈무리 : MEC++ 6장에 보면 갈무리 모드로 사용하신 분이 있다. carry 「 순」 올림 올림은 논리 회로 책이나 비교적 최근의 책인 CODE에서도 번역용어로 사용했다. computer(컴퓨터) 「 →」 전산기, 셈틀 computer architecture 「 순」 전산기 얼개 [D] debug 「 순」 벌레잡기 debugger 「 순」 벌레잡이 debugging 「 순」 벌레잡기 : 재밌는 제안이다. [E~U] floating point 「 순」 떠돌이 소수점 : 솔직히 둥둥소수점을 주장하고 싶다. factorial(팩토리얼) 「 →」 순차곱셈 :수학용어 사이트에서는 계승, 차례곱을 제안하고 있다. flowchart 「 순」 흐름도 : 현재는 플로우차트 혹은 순서도를 대부분 사용한다. FOR 「 순」 되풀이 halt 「 순」 멈춤 list(리스트) 「 →」 목록, 죽보(이)기 FIFO 「 순」 처음먼저내기, LIFO 「 순」 끝먼저내기 push-down 「 순」 끝먼저내기 : 스택 - 위키백과, 우리 모두의 백과사전 push-down list 「 순」 끝먼저내기 목록/죽보(이)기 push-up 「 순」 처음먼저내기 underflow 「 순」 아래넘침 한자 한자의 조어력은 분명 뛰어나다. 그리고 우리 전문용어는 대부분 한자어이다. 한글 용어만 사용할것인가? 외국어로만 사용할것인가? 가령 멈춤 문제, 정지 문제. 혹은 거품 정렬, 버블 정렬을 보자. 한국어와 한자를 같이 쓰면 안좋은가? 한자가 문제인가, 순우리말이 문제인가? 가장 좋고 올바른 전문용어가 있거나 만들 수 있다면 그 이상 바람직한 일은 없을 것이다. 문제는 좋은 용어란 무엇일까?에 대한 의문 그리고 어떻게 좋은 용어를 만드느냐는 것이다. 좋은 용어에 대한 정의가 사람에 따라 다를 수도 있다. 또한 유념해야할 점은 한 마디로 표현하기 힘들 수도 있다는 점이다. 이런 경우 한글로 표현하기 힘들어 어쩔 수 없이 원어 발음을 차용하는 경우가 의미를 정확하게 표현하기도 한다. 컴퓨터공학의 일반적 용어들, 예를 들어 List, Stack, Word problem 등을 보면 단어가 얼개 수준에서 그쳤음을 알 수 있다. 사실 용어가 컴퓨터 공학에서 의미하는 내용을 포괄하기란 무척이나 어렵다는 점이다. 좋은 전문용어를 어떻게 잘 선정할 것인가? 또는 새로 만들 것인가는 매번 고민하는 어려운 문제이지만 해결해야할 숙제다. 특히 전문용어 사용자에 대한 고려도 해야한다. 독자가 이해하지 못하거나 믿지 못할 용어는 곤란하다. 가능한 양쪽 모두 이해하고 소통할 수 있는 방향으로 전문 용어를 정리하고 고민해봐야 하지 않을까? 4 Random Number in a nutshell 2017 July 우리가 알고 있는 무작위 수는 사실 무작위 수가 아니다. 이번 글에서는 의사 무작위 수로 불리는 이유를 볼 것이다. 무작위 수의 성질을 3가지로 볼 수 있다. 무작위성(Randomness) : 말 그대로 수열이 무작위로 되어있는 성질 예측 불가능성 :다음 수를 예측할 수 없다는 성질 재현 불가능성 : 같은 수열을 재현할 수 없다는 성질 무작위 수를 분류한다면 약한 의사 무작위 수, 강한 의사 무작위 수 그리고 진정한 무작위 수가 된다. 약한 의사 무작위 수는 무작위성만 가지고 있으며, 강한 의사 무작위 수는 예측 불가능성까지, 진정한 무작위 수는 재현 불가능성까지 가진다. 기본적인 무작위 수 생성기인 선형 합동 생성기(Linear congruential generator, LCG)를 보자. LCG의 수식 \\({x}_{n+1} \\leftarrow (k \\times x_n + c)\\; mod \\; m\\) // 실제 stdlib/rand.c에서 쓰이는 LCG 코드 // ISO9899 static unsigned long int next = 1; int rand(void) // RAND_MAX assumed to be 32767 { next = next * 1103515245 + 12345; return (unsigned int)(next/65536) % 32768; } 선형 합동법의 단점을 보려는 것은 아니다. 선형합동법을 이용한 무작위 수 생성을 보면 재밌는 사실이 있다. \\(45 \\;6\\; 65\\; 86\\; 85\\; 66\\; 5\\; 46 \\; 25\\; 26\\; 45\\; 6\\; 65\\; 86\\; 85\\; 66\\; 5\\; 46 \\;25 \\;26 \\;45\\; 6\\; 65 \\;86 \\;85 \\;66 \\;…\\) 첫 번째 수인 \\(45\\)가 \\(11\\)번째 에서 다시 나타난다. 반복되는 수열 부분을 주기(period)라고 한다. 당연히 주기를 갖는 수열은 재현이 불가능하지는 않을것이다. 무작위 수 생성기로 사용해봤지만 수열이 반복한다면 생성한 수열의 예측이 가능하게 된다. \\({x}_{n+1} \\leftarrow r \\times x_n \\times (1 - x_n)\\) 초기 시드값을 \\(0\\)과 \\(1\\)사이의 값으로 해보면 좀 더 그럴듯한 난수열을 만들 수 있을 것이다. 수식을 반복해서 계산해보면 수열의 값은 \\([0,1]\\)의 부분구간인 \\([a,b]\\)에서 뛰게될것이다. \\(x_n\\) 으로 변환하면 \\(y_n \\leftarrow \\frac{x_n - a}{b-a}\\) “무작위” 수 \\(y_n\\)를 생성하는 수식을 얻을 수 있다 . 무작위 수열을 생성하는 컴퓨터 프로그램의 아이디어는 체이틴-콜모고로프 이론에 기초한다. 논문의 내용을 요약하면 이렇다. 무작위 수열을 생성하는 가장 짧은 프로그램의 짧은 길이를 가진 유한 수열의 무작위성을 정의한다. 그리고 프로그램이 길어질수록 수열은 더욱 무작위성을 띈다. 또한 프로그램이 만드는 수열이 수열의 길이만큼 복잡할 경우 가장 무작위하다는 것을 제안하고 있다. 간단하게 수열을 이진법으로 한다면 \\(01101\\)으로 된 수열을 \\(m\\)만큼 반복하여 만드는 짧은 프로그램을 생각해볼 수 있다. for i &lt;- to m output 0,1,1,0,1 프로그램은 23개의 아스키 문자와 변수 \\(m\\)을 포함하고 있다. 그리고 \\(m\\)은 프로그램 길이의 식인 \\(23 + log M\\) 이 된다. 그리고 프로그램은 \\(n=5m\\) 의 길이를 가지는 수열을 생성한다. 무작위성을 측정하는 방법 중 하나는 문자열의 길이와 프로그램 길이 비율을 맞추는 것이다. m의 반복으로 만들어지는 수열 \\(0,1,1,0,1\\)은 다음과 같은 무작위성을 가진다. \\(r \\leq \\frac{23 + \\log{m} }{5m}\\) 이 무작위성 비율의 \\(m\\)이 증가할수록 수열에서 \\(0\\) 혹은 \\(1\\)이 많아지는 경향이 있음을 알 수 있다. 극한으로 본다면 무작위성 비율은 0이다. 엄밀히 말해 무작위는 아니라는 의미다. 자 그러면, 특정 무작위 수열 \\(S\\)가 무작위 임을 증명하려면 어떻게 해야할까? \\(S\\)보다 짧은 프로그램이 없어야한다. 콜모고로프는 어떤 수열이 자기 자신의 길이와 같은 크기의 복잡성을 가질 때 그런 수열을 무작위적(randomness)라 부르자고 제안했다. \\(S\\)보다 짧은 프로그램이 없어야 한다는 의미는 “길이 \\(N\\)의 수열이 주어졌을때 이 수열이 복잡성 \\(N\\)을 가진다라는 것을 증명할 수 있는가?”라는 질문으로 바뀔 수 있다. 여기서 체이틴과 콜모고로프는 알고리즘적 정보이론을 만들면서 베리의 역설을 응용했음을 알 수 있다. “베리의 역설은 원래 영어에 대해 이야기하지만, 이는 너무 모호하다. 나는 대신 컴퓨터 프로그래밍 언어를 선택한다.” - 인포메이션 pp. 461 베리의 역설을 응용하면 아스키문자를 사용하여 정의될 수 없는 가장 작은 수가 무엇인가?가 된다. 만일 이 수가 발견된다면 역설이 등장할것이다. 다시 말해 수열이 프로그램 \\(P\\)에 의해서만 생성될수 있는지 확인하면 된다라는 말이 된다. 여기서 재밌는 결론이 나올 수 있는데, 괴델은 정의한 \\(PM\\)에서 어떤 공리 체계는 불완전하다는 것, 즉 \\(PM\\)에서 증명할 수 없는 정리가 있음을 보여주었다. 물론 길이가 긴 수열이 무작위라고 주장하는 다양한 정리가 있지만, 의사 무작위일 뿐이다. 체이틴-콜모고로프 논문의 핵심은 수열이 무작위 인지 아닌지 결코 알 수 없지만 적어도 프로그램으로 생성된 수열의 무작위성 정도를 측정할 수 있다는 것이다. 그리고 명제와 프로그램은 수학적으로 엄밀이 정의될 수 있다는 것이다. 러셀의 역설에서 시작한 괴델의 불완전성 정리도 튜링 기계의 멈춤 문제도 프로그램 내에서 정의될 수 있다는 의미가 된다. 진정한 무작위 수는 어디서 얻을 수 있을까? 방사선 관측기의 출력 제너 다이오드에 전압을 반대로 누출 시키기(Zener and Avalanche Breakdown/Diodes) 동전 던지기로 얻을 수 있는 비트 Reference 각 언어별 의사 무작위 수 생성 방법 무작위성 컴퓨터 프로그래밍의 예술 2 vols. 도널드 크누스 지음. 류광 옮김. 한빛미디어. 2006년. pp. 인포메이션. 제임스 글릭 지음. 박래선, 김태훈 옮김. 김상욱 감수. 동아시아. 2017년. pp. 441~ Numerical Recipes - The Art of Scientific Computing 3rd pp. 430- Gregory J. Chaitin. Algorithmic Information Theory. Cambridge University Press, Cambridge, 1993. pp. 179-183 (PART) 2017 October 5 Simplex Method와 양키스 2017 October George Bernard Dantzig (ˈdæntsɪɡ)가 1974년에 개발한 단체법(Simplex Method)을 보기 전에 Simplex Mothod의 뿌리인 Dynamic Programming을 보자. 잠깐, Dynamic Programming의 번역어를 아는가? 동적 계획법 혹은 다이나믹 프로그래밍이 익숙할 것이다. 이 용어는 수학자 리처드 벨만(Richard E. Bellman)이 정의한 용어인데, 당시 Dynamic Programming이라고 한 이유를 그의 자서전(Eye of the Hurricane: An Autobiography)에서 볼 수 있다. 나는 RAND 코퍼레이션에서 1950년의 가을을 보냈다. 여기에서 내게 주어진 첫 과제는 다단계 의사 결정 프로세스에 대해 적절한 용어를 명명하는 것이었다. ’동적 계획법’이라는 이름이 어디에서 왔는지 궁금하지 않은가? 1950년대는 내가 수학에 대해 연구하기에는 좋지 못한 시기였다. 우리는 그 때 워싱턴에서 윌슨이라는 사람과 함께 일하고 있었다. 윌슨은 연구라는 것에 대해 굉장히 병적인 공포를 가지고 있었다. 사람들이 그 앞에서 연구에 대해 이야기를 꺼내면 그는 완전히 미치다시피 했다. 그러나 불행히도 RAND는 공군 소속의 회사였고, 윌슨은 그 공군의 간부인 국방 위원장이었다. 그래서 내가 RAND 안에 있었을 때 윌슨을 비롯한 공군들이 내가 수학에 대해 연구하는 것을 보이지 않게 막는다는 것을 알 수 있었다. 처음 올 때는 나는 위의 문제에 대해 ’의사 결정 프로세스’라는 이름을 사용했지만, 여기에서 ’프로세스(Process)’라는 단어를 사용하는데 여러가지 차질이 생겨버리고 만 것이다. 그래서 나는 사람들이 알지 못하게 ’계획법(Programming)’이라는 단어를 붙였다. 또한 나는 이 프로세스가 다단계(multistage)로 이루어져 있으며, 시가변(time-varying)적인 성질을 가진 것으로부터 ’동적(Dynamic)’라는 단어를 사용했다. 이 단어야말로 내가 연구하는 알고리즘의 성질을 정확하게 짚어내었고, 게다가 윌슨에게도 피해를 입히지 않으며 공군도 이 단어에선 꼬투리를 잡지 못했으니 그야말로 일석이조의 효과를 누린 것이다. 프로그래밍으로 푼다는 의미보다는 수학적 모형을 만들어 해를 구해 최적 의사결정을 도모하는 수리 계획법(Mathematical Programming)에 가깝다. 수리 계획법에는 세가지 구성요소가 있는데, 의사 결정 변수(decision variable)와 목적 함수(objective function) 그리고 제약조건(constraints)이다. 그리고 종류에는 목적함수와 제약조건식이 1차식으로 표현되는 선형계획법(LP), 1차식으로 표현되지 않는 모형을 비선형계획법(NLP), 의사결정변수가 정수값만을 가지고 있는 정수계획법(IP), 목적함수가 여러개의 목표를 포함하고 있는 경우 목표계획법(GP), 여러 단계에 걸쳐 변수의 값을 결정하는 모형 동적계획법(DP)가 있다. 본론으로 들어와 선형계획법의 예를 보자. 제품 A, B를 만드는 회사에서 이익을 최대화하기 위해 생산계획을 수립하려고 한다. 공장 세개를 가지고 있다고 했을 때 제품의 이익을 정리한 표는 다음과 같다. 공장 제품1 제품2 가용시간 1 1 0 4 2 0 2 12 3 3 2 18 이익 3000 5000 제품 1을 \\(x_1\\), 제품2를 \\(x_2\\)라 하자. 그러면 최대화할 식을 \\(Max: 3x_1 + 5x_2\\) 로, 제약조건을 이렇게 할 수 있다. \\(x1 \\leq 4 \\\\ 2x_2 \\leq 12 \\\\ 3x_1 +2x_2 \\leq 18 \\\\x_1, x_2 \\ge 0\\) \\(x_1, x_2\\)의 값은 음수가 아니어야 한다.연립부등식으로 풀면 \\(x_2\\)의 식을 얻을 수 있다. \\(x_2 \\leq 9 - \\frac{3}{2}x_1\\) 앞의 실행가능조건(feasibility condition)을 이용하여 그래프를 그리면 다음과 같다. Desmos Graphing Calculator 0보다 크면서 선 안의 영역이 실행가능영역이다. \\(x_1 = 2 , x_2 = 6\\)이 되면서 \\((2,6)\\)라는 값이 목적함수(최대화할 식)의 최적해가 된다. 이처럼 도해법은 가장 직관적인 방법이다. 그러나 변수가 3개 이상이 되면 표현하기가 어려워지며 4개 이상이면 적용이 불가능하다. 이러한 문제를 일반적으로 해결 할 수 있는 방법이 필요하게 된다. 단체법(Simplex method) 댄치그가 개발한 단체법의 기본 개념은 최적해 후보에 대한 최적여부를 체계적으로 검토하여 가장 빠른 시간내에 최적해를 찾아내고자 하는 것이다. 단체법을 적용하기 전에 가장 해야할 일은 부등식을 등식으로 바꾸는 표준형(standard form)을 적용하는 것이다. 예를 들어 \\(2x_1 \\leq 50\\) 이라면 여유 변수(slack variable) S를 더하여 \\(2X_1 + S_1 = 50\\)으로 만들면 된다. 가령 미지수가 3개, 조건식이 3개인 변수인 문제가 있다고 가정하고 여유 변수, 즉 미지수가 3개나 더 추가가 될 경우에는 어떻게 해야할까. 일반적으로는 풀 수 없다. 그러나 여유 변수를 \\(0\\)으로 두면 미지수가 줄어들게 된다. 그리고 최초의 \\(0\\)이 아닌 값, 미지수를 기저가능(Basic feasible)해라고 한다. 기저가능해가 원점\\((0,0)\\)부터 시작한다고 하면 여유변수는 다음과 같을 것이다. \\(x_1 + s_1 = 4 \\\\ 2x_2 + s_2 = 12 \\\\ 3x_1 + 2x_2 + s_3 = 18 \\\\ s_1 = 4, s_2 = 12, s_3= 18\\) 하지만 이렇게 구한 값들은 목적함수에서 \\(0\\)이다. 목적함수를 최대화하기 위해 인접한 해, 꼭지점 값을 이동하면서 최적해를 찾으면 된다. 어느 방향\\((x,y)\\)으로 이동할 것인가가 문제가 되는데, \\(3x_1 + 5x_2\\) 계수가 가장 큰 \\(x_2\\)를 기저 변수로 선택하고 이동하면 될 것이다. 정리하면, 1. 표준형으로 변형하면 원점이 최초의 해가 된다. 2. 여유변수가 기저변수, 다른 변수는 비기저변수. 3. 최적화 검사 : 목적함수가 증가(감소) 여부, 인접한 더 좋은 해가 없다면 그 해가 최적해 4. 진입기저변수 선택. 문제를 바꿔서 설명해보겠다. \\(Max \\; z=2x_1 + x_2 \\\\ x_1 + 5x_2 \\leq 8 \\\\ 2x_1 + 3x_2 \\leq 6 \\\\ 3x_1 + x_2 \\leq 6\\) 제약조건을 여유변수를 이용하여 등식으로 바꾼다. \\(2x_1 - x_2 - z = 0 \\\\ x_1 - 5x_2 + s_1 = 8 \\\\ 2x_1 - 3x_2 + s_2 = 6 \\\\ 3x_1 + x_2 + s_3 = 6\\) Desmos Graphing Calculator 원점 \\((0,0)\\)에서 시작하면 초기가능해(혹은 CPS)를 얻을 수 있다. 물론 이 문제에서 원점은 최적값에는 못미치는 값이다. 단체법은 각 단계마다 목적 등식의 계수를 확인한 다음 최대값을 다음 단계의 기준으로 선택한다. 이 과정에서 기저변수를 \\(z, s_1, s_2, s_3\\)로 하여 시작한다. 그런 다음 새로운 기저 변수는 목적 등식에서 가장 큰 계수를 갖는 \\(x_1\\)이다. 변수 \\(x_1\\)이 어떻게 바뀌는지 알아보기 위해 비율 계수를 \\(a\\), 값을 \\(b\\)인 $ $로 값이 큰 방정식을 선택한다. 앞의 식에서 비율은 각각 \\(\\frac{1}{8}\\), \\(\\frac{2}{6}\\), \\(\\frac{3}{6}\\) 이 나오는데 마지막 비율의 값이 가장 크다. 그리고 마지막 비율은 마지막 등식에서 나오므로 \\(x_1\\)으로 치환될 기저 변수는 \\(s_3\\)가 된다. 실제로 이 과정은 가우스 소거법을 사용한다. 마지막 등식을 이용하여 다른 등식에 적절한 수를 곱하여 마지막 등식을 제외한 모든 등식에서 \\(x_1\\)을 제거한다. \\(x_1\\)을 제거하는 과정을 끝내면 다음과 같다. \\(-z - \\frac{2}{3}s_3+ \\frac{1}{3}x_2= -4 \\\\s_1- \\frac{1}{3}s_3+ \\frac{14}{3}x_2=6 \\\\ s_2-\\frac{2}{3}s_3+\\frac{7}{3}x_2=2 \\\\x_1+\\frac{1}{3}s_3+\\frac{1}{3}x_2=2\\) 나머지 비기저변수를 0으로 하면 새로운 기저 변수를 얻을 수 있다. 따라서 비기저변수인 s_3, x_2를 0으로 하면 다음과 같은 값을 얻을 수 있다. \\(z=4, s_1=6, s_2=2, x_1 =2\\) 앞의 그래프를 보면 \\((2,0)\\), 즉 극점에 도달한 것을 알 수 있다. 이전 값인 \\((0,0)\\) 보다는 큰 값이다. 그리고 같은 방법을 반복하는데 이번에는 \\(x_2\\)에 가장 큰 계수가 있는지 확인한다. 가장 큰 계수/상수는 두번째 등식의 \\(\\frac{14}{18}\\)이다. 따라서 새 기저변수는 두번째 등식에 있는 기저변수 \\(s_1\\)을 치환하는 \\(x_2\\)다. 앞의 과정을 두 번 반복하면 \\(x_1=\\frac{12}{7}\\)과 \\(x_2=\\frac{6}{7}\\)가 나오면서 \\(z\\)의 최대값인 \\(\\frac{30}{7}\\)이 나올것이다. 이는 \\(4.29\\)에 가까운 값이다. 이번 글에선 목적함수를 최대화하는 방법을 알아보았지만, 목적함수를 최소화하는 문제도 있고 부등식이 무한대인 선형 프로그램도 있다. 단체법이 흥미롭다면 카치안(L. G. Kachian)의 타원체 알고리즘(ellipsoid algorithm)을 공부해보면 좋을것이다. Reference Simplex algorithm https://en.wikipedia.org/wiki/Simplex_algorithm Dynamic programming - Wikipedia Linear Programming FAQ 위키백과 튜링 기계 https://ko.wikipedia.org/wiki/%ED%8A%9C%EB%A7%81%EA%B8%B0%EA%B3%84↩ CS 언플러그드 http://www.playsw.or.kr/repo/cs_unplugged/379↩ 류광의 번역 이야기 parameter, argument, 인자, 인수, 매개 변수 http://occamsrazr.net/tt/11↩ 수리과학연구정보센터 http://icms.kaist.ac.kr/new_sub05/sub05_04.php↩ 컴퓨터 프로그래밍의 예술 1 vols. 도널드 크누스 지음. 류광 옮김. 한빛미디어. 2006년. pp. 166↩ 컴퓨터 구조론. 김종현 지음. 생능출판. 2013년. pp. 97↩ 컴퓨터 개론. 강환수, 조진형, 신용현, 강환일 공저. 인피니티북스. 2015년. pp. 125↩ "]
]
